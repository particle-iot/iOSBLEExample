// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: logging.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// Logging levels.
enum Particle_Ctrl_Logging_LogLevel: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Note: The values here should match the values of the `LogLevel` enum defined in the Device OS
  /// code (see services/inc/logging.h)
  case invalidLogLevel // = 0
  case all // = 1
  static let trace = all
  case info // = 30
  case warn // = 40
  case error // = 50
  case none // = 70
  case UNRECOGNIZED(Int)

  init() {
    self = .invalidLogLevel
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalidLogLevel
    case 1: self = .all
    case 30: self = .info
    case 40: self = .warn
    case 50: self = .error
    case 70: self = .none
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .invalidLogLevel: return 0
    case .all: return 1
    case .info: return 30
    case .warn: return 40
    case .error: return 50
    case .none: return 70
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Particle_Ctrl_Logging_LogLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Particle_Ctrl_Logging_LogLevel] = [
    .invalidLogLevel,
    .all,
    .info,
    .warn,
    .error,
    .none,
  ]
}

#endif  // swift(>=4.2)

///*
/// Log handler types.
enum Particle_Ctrl_Logging_LogHandlerType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Note: The values here should match the values of the `log_config_handler_type` enum defined in
  /// the Device OS code (system/inc/system_logging.h)
  case invalidLogHandlerType // = 0

  /// StreamLogHandler
  case defaultStreamHandler // = 1

  /// JSONStreamLogHandler
  case jsonStreamHandler // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .invalidLogHandlerType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalidLogHandlerType
    case 1: self = .defaultStreamHandler
    case 2: self = .jsonStreamHandler
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .invalidLogHandlerType: return 0
    case .defaultStreamHandler: return 1
    case .jsonStreamHandler: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Particle_Ctrl_Logging_LogHandlerType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Particle_Ctrl_Logging_LogHandlerType] = [
    .invalidLogHandlerType,
    .defaultStreamHandler,
    .jsonStreamHandler,
  ]
}

#endif  // swift(>=4.2)

///*
/// Stream types.
enum Particle_Ctrl_Logging_StreamType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Note: The values here should match the values of the `log_config_stream_type` enum defined in
  /// the Device OS code (system/inc/system_logging.h)
  case invalidStreamType // = 0

  /// USB serial (Serial, USBSerial1, etc.)
  case usbSerialStream // = 1

  /// Hardware serial (Serial1, Serial2, etc.)
  case hwSerialStream // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .invalidStreamType
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalidStreamType
    case 1: self = .usbSerialStream
    case 2: self = .hwSerialStream
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .invalidStreamType: return 0
    case .usbSerialStream: return 1
    case .hwSerialStream: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Particle_Ctrl_Logging_StreamType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Particle_Ctrl_Logging_StreamType] = [
    .invalidStreamType,
    .usbSerialStream,
    .hwSerialStream,
  ]
}

#endif  // swift(>=4.2)

///*
/// Category filter.
struct Particle_Ctrl_Logging_LogFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Category name
  var category: String = String()

  /// Logging level
  var level: Particle_Ctrl_Logging_LogLevel = .invalidLogLevel

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// Serial stream parameters.
struct Particle_Ctrl_Logging_SerialStreamParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Interface index
  var index: UInt32 = 0

  /// Baud rate
  var baudRate: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// Add a log handler.
struct Particle_Ctrl_Logging_AddLogHandlerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Handler ID
  var id: String = String()

  /// Handler type
  var handlerType: Particle_Ctrl_Logging_LogHandlerType = .invalidLogHandlerType

  /// Default logging level
  var level: Particle_Ctrl_Logging_LogLevel = .invalidLogLevel

  /// Category filters
  var filters: [Particle_Ctrl_Logging_LogFilter] = []

  /// Stream type
  var streamType: Particle_Ctrl_Logging_StreamType = .invalidStreamType

  var streamParams: Particle_Ctrl_Logging_AddLogHandlerRequest.OneOf_StreamParams? = nil

  /// Serial stream parameters
  var serial: Particle_Ctrl_Logging_SerialStreamParams {
    get {
      if case .serial(let v)? = streamParams {return v}
      return Particle_Ctrl_Logging_SerialStreamParams()
    }
    set {streamParams = .serial(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_StreamParams: Equatable {
    /// Serial stream parameters
    case serial(Particle_Ctrl_Logging_SerialStreamParams)

  #if !swift(>=4.1)
    static func ==(lhs: Particle_Ctrl_Logging_AddLogHandlerRequest.OneOf_StreamParams, rhs: Particle_Ctrl_Logging_AddLogHandlerRequest.OneOf_StreamParams) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.serial, .serial): return {
        guard case .serial(let l) = lhs, case .serial(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

struct Particle_Ctrl_Logging_AddLogHandlerReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// Remove a log handler.
struct Particle_Ctrl_Logging_RemoveLogHandlerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Handler ID
  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_Logging_RemoveLogHandlerReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// Get the list of active log handlers.
struct Particle_Ctrl_Logging_GetLogHandlersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_Logging_GetLogHandlersReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Active handlers
  var handlers: [Particle_Ctrl_Logging_GetLogHandlersReply.Handler] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Handler {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Handler ID
    var id: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Particle_Ctrl_Logging_LogLevel: @unchecked Sendable {}
extension Particle_Ctrl_Logging_LogHandlerType: @unchecked Sendable {}
extension Particle_Ctrl_Logging_StreamType: @unchecked Sendable {}
extension Particle_Ctrl_Logging_LogFilter: @unchecked Sendable {}
extension Particle_Ctrl_Logging_SerialStreamParams: @unchecked Sendable {}
extension Particle_Ctrl_Logging_AddLogHandlerRequest: @unchecked Sendable {}
extension Particle_Ctrl_Logging_AddLogHandlerRequest.OneOf_StreamParams: @unchecked Sendable {}
extension Particle_Ctrl_Logging_AddLogHandlerReply: @unchecked Sendable {}
extension Particle_Ctrl_Logging_RemoveLogHandlerRequest: @unchecked Sendable {}
extension Particle_Ctrl_Logging_RemoveLogHandlerReply: @unchecked Sendable {}
extension Particle_Ctrl_Logging_GetLogHandlersRequest: @unchecked Sendable {}
extension Particle_Ctrl_Logging_GetLogHandlersReply: @unchecked Sendable {}
extension Particle_Ctrl_Logging_GetLogHandlersReply.Handler: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "particle.ctrl.logging"

extension Particle_Ctrl_Logging_LogLevel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_LOG_LEVEL"),
    1: .aliased(proto: "ALL", aliases: ["TRACE"]),
    30: .same(proto: "INFO"),
    40: .same(proto: "WARN"),
    50: .same(proto: "ERROR"),
    70: .same(proto: "NONE"),
  ]
}

extension Particle_Ctrl_Logging_LogHandlerType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_LOG_HANDLER_TYPE"),
    1: .same(proto: "DEFAULT_STREAM_HANDLER"),
    2: .same(proto: "JSON_STREAM_HANDLER"),
  ]
}

extension Particle_Ctrl_Logging_StreamType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_STREAM_TYPE"),
    1: .same(proto: "USB_SERIAL_STREAM"),
    2: .same(proto: "HW_SERIAL_STREAM"),
  ]
}

extension Particle_Ctrl_Logging_LogFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "category"),
    2: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.category) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 1)
    }
    if self.level != .invalidLogLevel {
      try visitor.visitSingularEnumField(value: self.level, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_Logging_LogFilter, rhs: Particle_Ctrl_Logging_LogFilter) -> Bool {
    if lhs.category != rhs.category {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_Logging_SerialStreamParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SerialStreamParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .standard(proto: "baud_rate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.baudRate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if self.baudRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.baudRate, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_Logging_SerialStreamParams, rhs: Particle_Ctrl_Logging_SerialStreamParams) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.baudRate != rhs.baudRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_Logging_AddLogHandlerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddLogHandlerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "handler_type"),
    3: .same(proto: "level"),
    4: .same(proto: "filters"),
    5: .standard(proto: "stream_type"),
    6: .same(proto: "serial"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.handlerType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.level) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.streamType) }()
      case 6: try {
        var v: Particle_Ctrl_Logging_SerialStreamParams?
        var hadOneofValue = false
        if let current = self.streamParams {
          hadOneofValue = true
          if case .serial(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.streamParams = .serial(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.handlerType != .invalidLogHandlerType {
      try visitor.visitSingularEnumField(value: self.handlerType, fieldNumber: 2)
    }
    if self.level != .invalidLogLevel {
      try visitor.visitSingularEnumField(value: self.level, fieldNumber: 3)
    }
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 4)
    }
    if self.streamType != .invalidStreamType {
      try visitor.visitSingularEnumField(value: self.streamType, fieldNumber: 5)
    }
    try { if case .serial(let v)? = self.streamParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_Logging_AddLogHandlerRequest, rhs: Particle_Ctrl_Logging_AddLogHandlerRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.handlerType != rhs.handlerType {return false}
    if lhs.level != rhs.level {return false}
    if lhs.filters != rhs.filters {return false}
    if lhs.streamType != rhs.streamType {return false}
    if lhs.streamParams != rhs.streamParams {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_Logging_AddLogHandlerReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddLogHandlerReply"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_Logging_AddLogHandlerReply, rhs: Particle_Ctrl_Logging_AddLogHandlerReply) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_Logging_RemoveLogHandlerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveLogHandlerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_Logging_RemoveLogHandlerRequest, rhs: Particle_Ctrl_Logging_RemoveLogHandlerRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_Logging_RemoveLogHandlerReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveLogHandlerReply"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_Logging_RemoveLogHandlerReply, rhs: Particle_Ctrl_Logging_RemoveLogHandlerReply) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_Logging_GetLogHandlersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLogHandlersRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_Logging_GetLogHandlersRequest, rhs: Particle_Ctrl_Logging_GetLogHandlersRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_Logging_GetLogHandlersReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLogHandlersReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "handlers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.handlers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.handlers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.handlers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_Logging_GetLogHandlersReply, rhs: Particle_Ctrl_Logging_GetLogHandlersReply) -> Bool {
    if lhs.handlers != rhs.handlers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_Logging_GetLogHandlersReply.Handler: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Particle_Ctrl_Logging_GetLogHandlersReply.protoMessageName + ".Handler"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_Logging_GetLogHandlersReply.Handler, rhs: Particle_Ctrl_Logging_GetLogHandlersReply.Handler) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
