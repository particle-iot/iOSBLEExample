// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: storage.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Particle_Ctrl_StorageType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case invalidStorage // = 0

  /// Internal flash
  case `internal` // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .invalidStorage
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalidStorage
    case 1: self = .internal
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .invalidStorage: return 0
    case .internal: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Particle_Ctrl_StorageType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Particle_Ctrl_StorageType] = [
    .invalidStorage,
    .internal,
  ]
}

#endif  // swift(>=4.2)

enum Particle_Ctrl_SectionType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case invalidSection // = 0

  /// Firmware module
  case firmware // = 1

  /// OTA backup
  case otaBackup // = 2

  /// Factory backup
  case factoryBackup // = 3

  /// Device configuration
  case config // = 4

  /// Emulated EEPROM
  case eeprom // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .invalidSection
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalidSection
    case 1: self = .firmware
    case 2: self = .otaBackup
    case 3: self = .factoryBackup
    case 4: self = .config
    case 5: self = .eeprom
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .invalidSection: return 0
    case .firmware: return 1
    case .otaBackup: return 2
    case .factoryBackup: return 3
    case .config: return 4
    case .eeprom: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Particle_Ctrl_SectionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Particle_Ctrl_SectionType] = [
    .invalidSection,
    .firmware,
    .otaBackup,
    .factoryBackup,
    .config,
    .eeprom,
  ]
}

#endif  // swift(>=4.2)

enum Particle_Ctrl_FirmwareModuleType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case invalidFirmwareModule // = 0

  /// Bootloader
  case bootloader // = 1

  /// System part
  case systemPart // = 2

  /// User part
  case userPart // = 3

  /// Monolithic firmware
  case monoFirmware // = 4

  /// NCP firmware
  case ncpFirmware // = 5

  /// Radio stack binary
  case radioStack // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .invalidFirmwareModule
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalidFirmwareModule
    case 1: self = .bootloader
    case 2: self = .systemPart
    case 3: self = .userPart
    case 4: self = .monoFirmware
    case 5: self = .ncpFirmware
    case 6: self = .radioStack
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .invalidFirmwareModule: return 0
    case .bootloader: return 1
    case .systemPart: return 2
    case .userPart: return 3
    case .monoFirmware: return 4
    case .ncpFirmware: return 5
    case .radioStack: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Particle_Ctrl_FirmwareModuleType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Particle_Ctrl_FirmwareModuleType] = [
    .invalidFirmwareModule,
    .bootloader,
    .systemPart,
    .userPart,
    .monoFirmware,
    .ncpFirmware,
    .radioStack,
  ]
}

#endif  // swift(>=4.2)

enum Particle_Ctrl_FirmwareModuleValidityFlag: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case noValidationErrors // = 0

  /// Integrity check failed
  case integrityCheckFailed // = 1

  /// Dependency check failed
  case dependencyCheckFailed // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .noValidationErrors
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noValidationErrors
    case 1: self = .integrityCheckFailed
    case 2: self = .dependencyCheckFailed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noValidationErrors: return 0
    case .integrityCheckFailed: return 1
    case .dependencyCheckFailed: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Particle_Ctrl_FirmwareModuleValidityFlag: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Particle_Ctrl_FirmwareModuleValidityFlag] = [
    .noValidationErrors,
    .integrityCheckFailed,
    .dependencyCheckFailed,
  ]
}

#endif  // swift(>=4.2)

enum Particle_Ctrl_SectionFlag: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case noSectionFlags // = 0

  /// Section data is readable
  case canRead // = 1

  /// Section data is writable
  case canWrite // = 2

  /// Section can be cleared
  case canClear // = 4

  /// Actual size of the section data can be determined
  case canGetSize // = 8

  /// Section needs to be cleared before writing
  case needClear // = 16
  case UNRECOGNIZED(Int)

  init() {
    self = .noSectionFlags
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noSectionFlags
    case 1: self = .canRead
    case 2: self = .canWrite
    case 4: self = .canClear
    case 8: self = .canGetSize
    case 16: self = .needClear
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noSectionFlags: return 0
    case .canRead: return 1
    case .canWrite: return 2
    case .canClear: return 4
    case .canGetSize: return 8
    case .needClear: return 16
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Particle_Ctrl_SectionFlag: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Particle_Ctrl_SectionFlag] = [
    .noSectionFlags,
    .canRead,
    .canWrite,
    .canClear,
    .canGetSize,
    .needClear,
  ]
}

#endif  // swift(>=4.2)

enum Particle_Ctrl_FileFormat: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Binary
  case bin // = 0

  /// miniz compressed
  case miniz // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .bin
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .bin
    case 1: self = .miniz
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .bin: return 0
    case .miniz: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Particle_Ctrl_FileFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Particle_Ctrl_FileFormat] = [
    .bin,
    .miniz,
  ]
}

#endif  // swift(>=4.2)

/// Start the firmware update process
struct Particle_Ctrl_StartFirmwareUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Size of the firmware binary
  var size: UInt32 = 0

  /// Format of the firmware binary
  var format: Particle_Ctrl_FileFormat = .bin

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_StartFirmwareUpdateReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Maximum chunk size
  var chunkSize: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Finish the firmware update process
struct Particle_Ctrl_FinishFirmwareUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// When `true` it will only validate the integity of the update but won't write it to flash
  var validateOnly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_FinishFirmwareUpdateReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Cancel the firmware update
struct Particle_Ctrl_CancelFirmwareUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_CancelFirmwareUpdateReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Send the firmware update file
struct Particle_Ctrl_FirmwareUpdateDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_FirmwareUpdateDataReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Describe the built-in storage
struct Particle_Ctrl_DescribeStorageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_DescribeStorageReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Storages
  var storage: [Particle_Ctrl_DescribeStorageReply.Storage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Section {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Section type
    var type: Particle_Ctrl_SectionType = .invalidSection

    /// Section size
    var size: UInt32 = 0

    /// SectionFlag flags
    var flags: UInt32 = 0

    /// Firmware module
    var firmwareModule: Particle_Ctrl_DescribeStorageReply.Section.FirmwareModule {
      get {return _firmwareModule ?? Particle_Ctrl_DescribeStorageReply.Section.FirmwareModule()}
      set {_firmwareModule = newValue}
    }
    /// Returns true if `firmwareModule` has been explicitly set.
    var hasFirmwareModule: Bool {return self._firmwareModule != nil}
    /// Clears the value of `firmwareModule`. Subsequent reads from it will return its default value.
    mutating func clearFirmwareModule() {self._firmwareModule = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct FirmwareModule {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Firmware module type
      var type: Particle_Ctrl_FirmwareModuleType = .invalidFirmwareModule

      /// Section index
      var index: UInt32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _firmwareModule: Particle_Ctrl_DescribeStorageReply.Section.FirmwareModule? = nil
  }

  struct Storage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Storage type
    var type: Particle_Ctrl_StorageType = .invalidStorage

    /// SectionFlag flags
    var flags: UInt32 = 0

    /// Storage sections
    var sections: [Particle_Ctrl_DescribeStorageReply.Section] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Particle_Ctrl_ReadSectionDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Storage index
  var storage: UInt32 = 0

  /// Section index
  var section: UInt32 = 0

  /// Offset
  var offset: UInt32 = 0

  /// Size
  var size: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_ReadSectionDataReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Section data
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_WriteSectionDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Storage index
  var storage: UInt32 = 0

  /// Section index
  var section: UInt32 = 0

  /// Offset
  var offset: UInt32 = 0

  /// Size
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_WriteSectionDataReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_ClearSectionDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Storage index
  var storage: UInt32 = 0

  /// Section index
  var section: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_ClearSectionDataReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_GetSectionDataSizeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Storage index
  var storage: UInt32 = 0

  /// Section index
  var section: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_GetSectionDataSizeReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Section data size
  var size: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// Get firmware module info.
struct Particle_Ctrl_GetModuleInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Particle_Ctrl_GetModuleInfoReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Firmware modules
  var modules: [Particle_Ctrl_GetModuleInfoReply.Module] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Dependency {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Module type
    var type: Particle_Ctrl_FirmwareModuleType = .invalidFirmwareModule

    /// Module index
    var index: UInt32 = 0

    /// Module version
    var version: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Module {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Module type
    var type: Particle_Ctrl_FirmwareModuleType = .invalidFirmwareModule

    /// Module index
    var index: UInt32 = 0

    /// Module version
    var version: UInt32 = 0

    /// Module size
    var size: UInt32 = 0

    /// Validity flags (see FirmwareModuleValidityFlag)
    var validity: UInt32 = 0

    /// Module dependencies
    var dependencies: [Particle_Ctrl_GetModuleInfoReply.Dependency] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Particle_Ctrl_StorageType: @unchecked Sendable {}
extension Particle_Ctrl_SectionType: @unchecked Sendable {}
extension Particle_Ctrl_FirmwareModuleType: @unchecked Sendable {}
extension Particle_Ctrl_FirmwareModuleValidityFlag: @unchecked Sendable {}
extension Particle_Ctrl_SectionFlag: @unchecked Sendable {}
extension Particle_Ctrl_FileFormat: @unchecked Sendable {}
extension Particle_Ctrl_StartFirmwareUpdateRequest: @unchecked Sendable {}
extension Particle_Ctrl_StartFirmwareUpdateReply: @unchecked Sendable {}
extension Particle_Ctrl_FinishFirmwareUpdateRequest: @unchecked Sendable {}
extension Particle_Ctrl_FinishFirmwareUpdateReply: @unchecked Sendable {}
extension Particle_Ctrl_CancelFirmwareUpdateRequest: @unchecked Sendable {}
extension Particle_Ctrl_CancelFirmwareUpdateReply: @unchecked Sendable {}
extension Particle_Ctrl_FirmwareUpdateDataRequest: @unchecked Sendable {}
extension Particle_Ctrl_FirmwareUpdateDataReply: @unchecked Sendable {}
extension Particle_Ctrl_DescribeStorageRequest: @unchecked Sendable {}
extension Particle_Ctrl_DescribeStorageReply: @unchecked Sendable {}
extension Particle_Ctrl_DescribeStorageReply.Section: @unchecked Sendable {}
extension Particle_Ctrl_DescribeStorageReply.Section.FirmwareModule: @unchecked Sendable {}
extension Particle_Ctrl_DescribeStorageReply.Storage: @unchecked Sendable {}
extension Particle_Ctrl_ReadSectionDataRequest: @unchecked Sendable {}
extension Particle_Ctrl_ReadSectionDataReply: @unchecked Sendable {}
extension Particle_Ctrl_WriteSectionDataRequest: @unchecked Sendable {}
extension Particle_Ctrl_WriteSectionDataReply: @unchecked Sendable {}
extension Particle_Ctrl_ClearSectionDataRequest: @unchecked Sendable {}
extension Particle_Ctrl_ClearSectionDataReply: @unchecked Sendable {}
extension Particle_Ctrl_GetSectionDataSizeRequest: @unchecked Sendable {}
extension Particle_Ctrl_GetSectionDataSizeReply: @unchecked Sendable {}
extension Particle_Ctrl_GetModuleInfoRequest: @unchecked Sendable {}
extension Particle_Ctrl_GetModuleInfoReply: @unchecked Sendable {}
extension Particle_Ctrl_GetModuleInfoReply.Dependency: @unchecked Sendable {}
extension Particle_Ctrl_GetModuleInfoReply.Module: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "particle.ctrl"

extension Particle_Ctrl_StorageType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_STORAGE"),
    1: .same(proto: "INTERNAL"),
  ]
}

extension Particle_Ctrl_SectionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_SECTION"),
    1: .same(proto: "FIRMWARE"),
    2: .same(proto: "OTA_BACKUP"),
    3: .same(proto: "FACTORY_BACKUP"),
    4: .same(proto: "CONFIG"),
    5: .same(proto: "EEPROM"),
  ]
}

extension Particle_Ctrl_FirmwareModuleType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_FIRMWARE_MODULE"),
    1: .same(proto: "BOOTLOADER"),
    2: .same(proto: "SYSTEM_PART"),
    3: .same(proto: "USER_PART"),
    4: .same(proto: "MONO_FIRMWARE"),
    5: .same(proto: "NCP_FIRMWARE"),
    6: .same(proto: "RADIO_STACK"),
  ]
}

extension Particle_Ctrl_FirmwareModuleValidityFlag: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_VALIDATION_ERRORS"),
    1: .same(proto: "INTEGRITY_CHECK_FAILED"),
    2: .same(proto: "DEPENDENCY_CHECK_FAILED"),
  ]
}

extension Particle_Ctrl_SectionFlag: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_SECTION_FLAGS"),
    1: .same(proto: "CAN_READ"),
    2: .same(proto: "CAN_WRITE"),
    4: .same(proto: "CAN_CLEAR"),
    8: .same(proto: "CAN_GET_SIZE"),
    16: .same(proto: "NEED_CLEAR"),
  ]
}

extension Particle_Ctrl_FileFormat: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BIN"),
    1: .same(proto: "MINIZ"),
  ]
}

extension Particle_Ctrl_StartFirmwareUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartFirmwareUpdateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .same(proto: "format"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 1)
    }
    if self.format != .bin {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_StartFirmwareUpdateRequest, rhs: Particle_Ctrl_StartFirmwareUpdateRequest) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.format != rhs.format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_StartFirmwareUpdateReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StartFirmwareUpdateReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chunk_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.chunkSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chunkSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.chunkSize, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_StartFirmwareUpdateReply, rhs: Particle_Ctrl_StartFirmwareUpdateReply) -> Bool {
    if lhs.chunkSize != rhs.chunkSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_FinishFirmwareUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FinishFirmwareUpdateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "validate_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.validateOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.validateOnly != false {
      try visitor.visitSingularBoolField(value: self.validateOnly, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_FinishFirmwareUpdateRequest, rhs: Particle_Ctrl_FinishFirmwareUpdateRequest) -> Bool {
    if lhs.validateOnly != rhs.validateOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_FinishFirmwareUpdateReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FinishFirmwareUpdateReply"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_FinishFirmwareUpdateReply, rhs: Particle_Ctrl_FinishFirmwareUpdateReply) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_CancelFirmwareUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CancelFirmwareUpdateRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_CancelFirmwareUpdateRequest, rhs: Particle_Ctrl_CancelFirmwareUpdateRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_CancelFirmwareUpdateReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CancelFirmwareUpdateReply"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_CancelFirmwareUpdateReply, rhs: Particle_Ctrl_CancelFirmwareUpdateReply) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_FirmwareUpdateDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FirmwareUpdateDataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_FirmwareUpdateDataRequest, rhs: Particle_Ctrl_FirmwareUpdateDataRequest) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_FirmwareUpdateDataReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FirmwareUpdateDataReply"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_FirmwareUpdateDataReply, rhs: Particle_Ctrl_FirmwareUpdateDataReply) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_DescribeStorageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DescribeStorageRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_DescribeStorageRequest, rhs: Particle_Ctrl_DescribeStorageRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_DescribeStorageReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DescribeStorageReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "storage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.storage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.storage.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.storage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_DescribeStorageReply, rhs: Particle_Ctrl_DescribeStorageReply) -> Bool {
    if lhs.storage != rhs.storage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_DescribeStorageReply.Section: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Particle_Ctrl_DescribeStorageReply.protoMessageName + ".Section"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "size"),
    3: .same(proto: "flags"),
    4: .standard(proto: "firmware_module"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.flags) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._firmwareModule) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .invalidSection {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.flags != 0 {
      try visitor.visitSingularUInt32Field(value: self.flags, fieldNumber: 3)
    }
    try { if let v = self._firmwareModule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_DescribeStorageReply.Section, rhs: Particle_Ctrl_DescribeStorageReply.Section) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.size != rhs.size {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs._firmwareModule != rhs._firmwareModule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_DescribeStorageReply.Section.FirmwareModule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Particle_Ctrl_DescribeStorageReply.Section.protoMessageName + ".FirmwareModule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .invalidFirmwareModule {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_DescribeStorageReply.Section.FirmwareModule, rhs: Particle_Ctrl_DescribeStorageReply.Section.FirmwareModule) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_DescribeStorageReply.Storage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Particle_Ctrl_DescribeStorageReply.protoMessageName + ".Storage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "flags"),
    3: .same(proto: "sections"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.flags) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sections) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .invalidStorage {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.flags != 0 {
      try visitor.visitSingularUInt32Field(value: self.flags, fieldNumber: 2)
    }
    if !self.sections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sections, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_DescribeStorageReply.Storage, rhs: Particle_Ctrl_DescribeStorageReply.Storage) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.sections != rhs.sections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_ReadSectionDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadSectionDataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "storage"),
    2: .same(proto: "section"),
    3: .same(proto: "offset"),
    4: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.storage) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.section) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storage != 0 {
      try visitor.visitSingularUInt32Field(value: self.storage, fieldNumber: 1)
    }
    if self.section != 0 {
      try visitor.visitSingularUInt32Field(value: self.section, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularUInt32Field(value: self.offset, fieldNumber: 3)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_ReadSectionDataRequest, rhs: Particle_Ctrl_ReadSectionDataRequest) -> Bool {
    if lhs.storage != rhs.storage {return false}
    if lhs.section != rhs.section {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_ReadSectionDataReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadSectionDataReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_ReadSectionDataReply, rhs: Particle_Ctrl_ReadSectionDataReply) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_WriteSectionDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteSectionDataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "storage"),
    2: .same(proto: "section"),
    3: .same(proto: "offset"),
    4: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.storage) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.section) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.offset) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storage != 0 {
      try visitor.visitSingularUInt32Field(value: self.storage, fieldNumber: 1)
    }
    if self.section != 0 {
      try visitor.visitSingularUInt32Field(value: self.section, fieldNumber: 2)
    }
    if self.offset != 0 {
      try visitor.visitSingularUInt32Field(value: self.offset, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_WriteSectionDataRequest, rhs: Particle_Ctrl_WriteSectionDataRequest) -> Bool {
    if lhs.storage != rhs.storage {return false}
    if lhs.section != rhs.section {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_WriteSectionDataReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteSectionDataReply"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_WriteSectionDataReply, rhs: Particle_Ctrl_WriteSectionDataReply) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_ClearSectionDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClearSectionDataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "storage"),
    2: .same(proto: "section"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.storage) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.section) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storage != 0 {
      try visitor.visitSingularUInt32Field(value: self.storage, fieldNumber: 1)
    }
    if self.section != 0 {
      try visitor.visitSingularUInt32Field(value: self.section, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_ClearSectionDataRequest, rhs: Particle_Ctrl_ClearSectionDataRequest) -> Bool {
    if lhs.storage != rhs.storage {return false}
    if lhs.section != rhs.section {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_ClearSectionDataReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClearSectionDataReply"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_ClearSectionDataReply, rhs: Particle_Ctrl_ClearSectionDataReply) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_GetSectionDataSizeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSectionDataSizeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "storage"),
    2: .same(proto: "section"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.storage) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.section) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.storage != 0 {
      try visitor.visitSingularUInt32Field(value: self.storage, fieldNumber: 1)
    }
    if self.section != 0 {
      try visitor.visitSingularUInt32Field(value: self.section, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_GetSectionDataSizeRequest, rhs: Particle_Ctrl_GetSectionDataSizeRequest) -> Bool {
    if lhs.storage != rhs.storage {return false}
    if lhs.section != rhs.section {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_GetSectionDataSizeReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSectionDataSizeReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_GetSectionDataSizeReply, rhs: Particle_Ctrl_GetSectionDataSizeReply) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_GetModuleInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetModuleInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_GetModuleInfoRequest, rhs: Particle_Ctrl_GetModuleInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_GetModuleInfoReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetModuleInfoReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "modules"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.modules) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.modules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modules, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_GetModuleInfoReply, rhs: Particle_Ctrl_GetModuleInfoReply) -> Bool {
    if lhs.modules != rhs.modules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_GetModuleInfoReply.Dependency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Particle_Ctrl_GetModuleInfoReply.protoMessageName + ".Dependency"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "index"),
    3: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .invalidFirmwareModule {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 2)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_GetModuleInfoReply.Dependency, rhs: Particle_Ctrl_GetModuleInfoReply.Dependency) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.index != rhs.index {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Particle_Ctrl_GetModuleInfoReply.Module: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Particle_Ctrl_GetModuleInfoReply.protoMessageName + ".Module"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "index"),
    3: .same(proto: "version"),
    4: .same(proto: "size"),
    5: .same(proto: "validity"),
    6: .same(proto: "dependencies"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.validity) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.dependencies) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .invalidFirmwareModule {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 2)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 3)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 4)
    }
    if self.validity != 0 {
      try visitor.visitSingularUInt32Field(value: self.validity, fieldNumber: 5)
    }
    if !self.dependencies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dependencies, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Particle_Ctrl_GetModuleInfoReply.Module, rhs: Particle_Ctrl_GetModuleInfoReply.Module) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.index != rhs.index {return false}
    if lhs.version != rhs.version {return false}
    if lhs.size != rhs.size {return false}
    if lhs.validity != rhs.validity {return false}
    if lhs.dependencies != rhs.dependencies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
